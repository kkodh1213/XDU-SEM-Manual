[[Java语言基础]]
## 枚举类enum
1. 枚举是一组常量的集合
   定义格式
```
enum 枚举类{
对象名1(实参列表),对象名2(实参列表),...;//常量对象必须写在最前面，参数列表与构造器对应一致
定义属性;
构造器;
成员方法;
}
```
- 使用枚举关键字enum实现枚举类的时候默认会继承Enum类
- 注意参数列表确认使用的是哪一个构造器
- 如果使用的是无参构造器，参数列表和括号都可以省略
- 枚举对象必须位于枚举类的首位
- enum无法继承其他类，因为enum隐式继承了Enum类，但是可以实现接口
2. Enum中包含的方法
   - name方法, 输出枚举对象的名称
   - ordinal方法, 输出枚举对象的定义编号，从0开始
   - values方法, 返回枚举对象的数组
   - valueOf方法, 将字符串匹配为已有的枚举对象，找到就返回，没找到就报错
   - compareTo方法, 比较两个枚举对象，比较的就是两者的位置号，得到的是前者位置号减去后者的位置号
## 八大Wrapper类

| 基本类型    | 包装类       |
| ------- | --------- |
| ==boolean== | ==Boolean==   |
| ==char==    | ==Character== |
| byte    | Byte      |
| short   | Short     |
| int     | Integer   |
| long    | Long      |
| float   | Float     |
| double  | Double    |
jdk5之前是使用包装类创建实例对象的方法手动装箱
手动拆箱则是使用实例对象的Value方法
自动装箱：使用对应类型变量赋值给包装类实例，底层用的valueOf方法，对于Integer复制装箱，如果值在-127到128之间则直接返回值，否则new一个新的对象
自动拆箱：将包装类实例对象直接赋值给对应类型变量

## String 类
String类用于保存字符串也就是一组字符序列
字符串常量是使用双引号括起来的字符序列
字符串的字符使用Unicode编码，一个字符无论是字母还是汉字都是占两个字节
字符串常用的构造器：
```java
String s1 = new String();
String s2 = new String(String original);
String s3 = new String(char[] a);
String s4 = new String(char[] a,int startIndex,int count);
String s5 = new String(byte[] b);
```
String类实现了接口Serializable表明String 可以串行化，可以在网络进行传输
String类实现了Comparable接口表明String可以相互比较大小
String类是final类不能被继承
String类中有一个private final char value[]字符数组用于存储字符串的内容，复制后不能修改(地址不可修改)，不可以指向新的对象，内容的修改是可以的

**String对象创建方式**
直接赋值
```
String s = "hsp";
```
先从常量池中查看是否存在该字符串对应的数据空间，如果存在则直接指向，否则重新创建然后指向
s直接指向常量池
调用构造器
```
String s2 = new String("hsp")
```
首先堆中创建空间，里面维护了value属性，指向常量池的字符串空间，如果常量池中没有则重新创建，如果有则通过value直接指向，最终指向的是堆中的空间地址
s2指向堆中对象value，然后指向常量池

intern方法如果池中已经包含了一个等于该String对象的字符串则返回池中的字符串，否则将此String对象添加到池中，并且返回String对象的引用。最终返回的是常量池的地址

创建常量池对象的时候会编译器进行判断例如"abc"+"def"实际上就是"abcdef"
```
String a="hello";
String b="abc";
String c=a+b;
```
上述过程一共创建了四个对象，首先创建了a和b对象，然后创建StringBuilder对象进行append操作，最后返回一个String对象返回给c，所以最后常量池中有三个String对象

String类是保存字符串常量的，所以每次更新都会在常量池中重新开辟空间，然后重新指向

**String 常用方法**
equals 区分大小写判断内容是否相等
equalsIgnoreCase 忽略大小写判断字符串内容是否相等
length 获取字符个数
IndexOf 获取字符在字符串第一次出现的索引，找不到就返回-1
lastIndexOf 获取字符在字符串中最后出现的索引，如果找不到就返回-1
substring 截取指定范围的字符串
trim 去掉字符串前后空格
charAt 获取某索引处的字符，字符串不可以直接使用索引方式获取对应位置的字符
toUpperCase 将字符串字母全部变为大写
tolowerCase 将字符串字母全部变为小写
concat 拼接字符串，可以连续使用
replace 将字符串中内容进行替换
split 以某字符为标准对字符串进行切割，最后返回一个字符串数组
compareTo 判断字符串中对应字符是都相等，长度相等，如果不相等就返回对应字符的差后续不再比较，返回的是int类型，长度不相等直接返回长度之差，如果长度相等且字符相等则返回0
toCharArray 将字符串转化为字符数组
format 根据占位符的位置填充变量的信息，占位符的格式与变量数据类型一致

## StringBuffer 类
StringBuffer代表可变字符串，可以直接对字符串内容进行修改，更新的时候直接更新内容，而不是更新地址
其父类属性中的char[] value不是final类型，存放在堆中，StringBuffer是final类不能继承
new StringBuffer(); 创建一个大小为16的char[]数组存储字符串
new StringBuffer(num); 通过构造器存储指定大小的字符串
new StringBuffer(string): 创建目标字符串长度加16的字符串
增append删delete改replace查IndexOf插insert获取长度length

## StringBuilder
StringBulider不是线程安全的，在用字符串缓冲区被单个线程使用的时候建议优先使用
StringBuilder是final类，其对象的字符串序列仍然存在父类的字符数组中

StringBuilder和StringBuffer一样都是代表可变的字符序列 ，并且方法也一样
String是不可变字符序列，但是复用率高，对字符串进行大量修改的时候不要使用String
StringBuffer是可变字符序列，效率较高，线程安全，使用synchronized,多线程操作的时候使用这个
StringBuilder是可变字符序列，效率最高，线程不安全，单线程操作的时候用这个

## Math类
静态方法：
abs绝对值
pow幂运算
ceil向上取整
floor向下取整
round四舍五入
sqrt求算数平方根
random返回[0, 1)的随机数

## Arrays类
toString 返回数据的字符串格式
sort 排序从小到大，也可以传入接口Comparator实现定制排序
Array.sort(arr,new Comparator(){})使用实现了Comparator接口的匿名内部类，要求实现compare方法
定制排序实例
```java
public class ArraySort {  
    public static void main(String[] args) {  
        int[] arr = {1, -2, 8, 0, 20};  
        bubblesort02(arr, new Comparator() {  
            @Override  
            public int compare(Object o1, Object o2) {  
                int i1 = (Integer) o1;  
                int i2 = (Integer) o2;  
                return i1 - i2;  
            }  
        });  
 
        System.out.println("排序后的情况：");  
        System.out.println(Arrays.toString(arr));  
  
  
    }  
    public static void bubblesort02(int[] arr, Comparator c) {  
        int temp = 0;  
        for (int i = 0; i < arr.length - 1; i++) {  
            for (int j = 0; j < arr.length - 1 - i; j++) {  
                if (c.compare(arr[j], arr[j + 1]) > 0) {  
                    temp = arr[j];  
                    arr[j] = arr[j + 1];  
                    arr[j + 1] = temp;  
                }  
            }  
        }  
    }
    
```

fill将原有数组使用某数进行填充
copyOf对数组元素进行复制，并且指定数组赋值长度，长度大于原数组则后续都填充null
equals 判断两个数组元素内容是否完全一致
asList 将一组值转换为List

## System类
exit 退出当前程序
arraycopy 复制数组元素
currentTimeMillens 返回当前时间距离1970年1月1号的毫秒数
gc 运行垃圾回收机制

## BigInteger类和BigDecimal类
这两个类分别用于表示特别大的整数和特别大的浮点数
对其进行加减乘除的时候需要使用对应的方法
加法 add
减法 subtract
乘法 multiply
除法 devide,对于除不尽的无限循环小数使用ROUND_CEILING，保留到分子的精度

## 日期类
### Date
无参构造器获取当前时间，得到的是国外的格式，如果传参long型可以通过毫秒数输出时间
SimpleDateFormat格式化和解析日期的类，创建对象并且指定相应的格式，格式使用的字母是固定好的
### Calendar
Calendar是一个抽象类，构造器是私有的，通过getInstance获取实例，new不出来
```
Calendar c = Calendar.getInstance();
c.get(Calendar.YEAR);
c.get(Calendar.MONTH)+1;
...
```
Calendar没有对应可视化的方法，需要使用对应方法自由组合
线程不安全
### 第三代日期类
LocalDate, LocalTime, LocalDateTime
DateTimeFormatterofPattern
Instant