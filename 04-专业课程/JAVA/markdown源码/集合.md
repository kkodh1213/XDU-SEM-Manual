[[Java语言基础]]
 可以动态保存任意多个对象，使用比较方便
集合分为两大类：Collection和Map
- Collection分为List和Set，List分为ArrayList,LinkedList和Vector；Set分为HashSet和TreeSet，单例集合
- Map分为HashMap，HashTable，TreeMap,LinkedHashMap和Properties, 双例集合，可以存放Key-Value
#一、Collection接口
collection的实现子类可以存放多个元素，每个元素可以是Object，
接口常用方法：
add 添加单个元素
remove 删除指定元素
contains 查找某个元素是否存在
size 获取元素个数
isEmpty 判断集合是否非空
clear 清空
addAll 添加多个元素
containsAll 查找多个元素是否都存在
removeAll 删除多个元素

遍历方式：
1. 使用Iterator迭代器对象，所有实现了Collection接口的集合类都有一个iterator方法，所以返回一个·实现了iterator接口的对象，即返回一个迭代器
```
Iterator iterator=col.iterator();
```
通过上述方法得到迭代器，然后使用iterator.next方法判断是否还有下一个对象，在调用该方法之前应该先调用hasNext方法
快捷键itit，退出遍历循环后指向最后一个元素，如果希望再次遍历需要重置迭代器iterator=col.iterator();
2. 增强for循环可以用来遍历，增强for的底层还是迭代器

## List接口
List 集合中每个元素有序并且都有对应的索引，索引是从0开始的list.get(索引)得到对应元素值
subList(from, to)
list.get(索引)
set(索引，修改后的值)

### ArrayList
ArrayList是线程不安全的（没有synchronized），但是执行效率高 ， ArrayList允许加入null，并且多个，ArrayList是由数组来实现数据存储的
创建对象的时候ArrayList中维护了一个Object类的数组elementData来存储数据
当创建对象的时候，如果使用的是无参构造器，则初始化容量是0，添加元素的时候首先判断是否需要扩容，如果需要扩容，则扩容后的容量是10，下一次如果容量不够就是扩容为容量的1.5倍
如果创建的时候使用了规定容量的有参构造器，则需要扩容的时候就直接扩容该容量的1.5倍

### Vector
Vector是线程安全的，但是执行效率没有那么高，其底层也是一个对象数组elementData，Vector相比于ArrayList是按照2倍进行扩容

### LinkedList
LinkedList底层实现了双向列表和双向队列的特点，可以添加任意元素，元素可以重复，包括null，线程不安全没有实现同步
LinkedList底层维护了一个双向链表
其中两个属性first和last分别指向首节点和尾节点
每个节点又维护了三个属性，prev，next和item三个属性，prev指向前面节点，last指向后面节点 ，LinkedList的添加和删除并不是通过数组来完成的，效率比较高

创建Node类使用next引用赋值指向其他Node类
LinkedList默认删除的是第一个节点

### ArrayList与LinkedList的比较

|            | 底层结构 | 增删的效率       | 改查的效率 |
| ---------- | ---- | ----------- | ----- |
| ArrayList  | 可变数组 | 较低，采用的是数组扩容 | 较高    |
| LinkedList | 双向链表 | 较高，采用的是链表追加 | 较低    |
改查多使用ArrayList，增删多使用LinkedList，两者均是线程不安全的，尽可能使用单线程

## Set接口
无需的，添加取出的顺序不一样，没有索引
不允许重复，null也只能一个
Set迭代的时候，可以使用迭代器或者使用增强for循环，不可以使用索引进行获取
Set接口实现类输出多次顺序都是一样的

### HashSet
Hashset底层是Hashmap，可以存放null，但是只可以有一个null，即元素不能重复
HashSet不保证存放元素的顺序和取出的顺序一致，取决于hash后在确定索引的结果
刚开始的时候初始化大小为16，阈值是75%即12，达到临界值就会变为2倍扩容到32，这里的size指的是所有节点的个数，无论是挂在一个链表上的还是在这个集合中的，链表后面超过8个就转化为红黑树，如果table不到64，但是链表已经超过8，则table会自动扩容，直到达到64

添加一个元素时，先得到hash值，转成索引值
找到存储表table，看这个索引位置是否已经存放已有的元素
如果没有则直接加入
如果有则使用equals比较，如果相同则放弃添加，如果不相同则添加到最后
如果一个链表的元素达到树化临界值8，并且table的大小达到64，则自动转化为红黑树

集合判断一个对象是否相同是通过判断hash码和equals方法来实现的，可以对hashCode和equals方法实现重写实现对对象相等的判别

### LinkedHashSet
LinkedHashSet是HashSet的子类，它的底层维护的是一个LinkedHashMap，底层维护了一个数组+双向链表
使用hashcode来确定元素的存储位置，同时使用链表维护元素的次序，LinkedHashMap不允许添加重复元素

在LinkedHashSet中维护了一个hash表和一个双向链表，添加一个元素的时候，首先求hash值，再求索引，确定该元素在table表上的位置，然后将添加的元素加入到双向链表中

第一次存储的时候直接将table扩容到16，存放的节点是LinkedHashMap$Entry类型

### TreeSet
当我们使用无参构造器创建TreeSet时候，仍然是无序的
如果想要排序可以使用Comparator接口，定义一个新的匿名类并且对compare方法进行重写
经过比较最后得到的是一个二叉排序树

#二、Map接口
Map接口实现类的特点，用于保存具有映射关系的数据Key-Value
put(key,value)用于放入对应的键值对，Map中的key和value是任何引用类型，会封装到HashMap$Node对象中
Map中的key不允许重叠，添加key相等键值对的时候会替换旧的值
Map中key和value均可以为空，但是key为空只能有一个
key与value是一对一的关系，通过key可以找到对应的value
key-value使用HashMap的node存储，node实现了entry接口，一对key-value就是一个entry
真正的key-value是存储在HashMap$Node里面，Set和Collection只是对其的引用
为了方便遍历，创建了一个EntrySet集合，该集合存放类型是Entry，Entry存储key-value,存储的类型是HashMap$Node，方便进行遍历，因为Map.Entry提供了重要方法

HashMap没有实现同步因此是线程不安全的
**常用方法**
put添加键值对
remove根据键删除键值对
get根据键获取值
size获取元素个数
isEmpty判断Map是否为空
clear清除Map
containsKey输出所有键值对的键

**遍历方法**
1. 先取出所有的key，再通过key取出对应的value
   取出keySet，再使用map.getkey()
   使用增强for循环，迭代器
2. 把所有的value取出
   使用values得到所有的value
   使用增强for循环，迭代器
3. 通过EntrySet的，使用entrySet取出k-v
   将entry对象转为Map.Entry
   使用getKey和getValue
   使用迭代器或者增强for然后向下转型将HashMap$Node转化为Map.Entry

### HashMap
HashMap的扩容机制相同，HashMap是Map接口使用频率最高的实现类，HashMap是以key-value对的方式来存储数据
key不可以重复，否则就会直接进行覆盖
key值可以是null，value值也可以是null，与HashSet一样不保证映射的顺序，因为底层是按照hash表的形式来存储的
HashMap没有实现同步，因此是线程不安全的

### TreeMap
TreeSet的底层就是TreeMap，使用的是键排序，同样可以在构造器中提供匿名内部类comparator的自定义compare方法
进行的排序比较如果相等那就不加进去
### HashTable
HashTable是以key-value对的方式来存储数据
HashTable的键和值都不能为null，HashTable是线程安全的
HashTable的初始大小为11，临界值为75%，扩容的时候是原来大小的2倍+1

### Properties
Properties的使用特点类似于Hashtable，继承了HashTable，所以不能存储null
Properties还可以用于从Properties文件中加载数据到Properties对象进行读取和修改

## 开发中如何合理选择集合实现类
使用什么集合实现类主要取决于业务操作的特点，然后根据根据其特性选择

1. 一组对象(单例)：Collection接口：
- 允许重复：List
- 增删多：LinkedList，底层维护了一个双向链表
- 改查多：ArrayList，底层维护了一个Object类型的可变数
2. 不允许重复：Set
- 无序：HashSet 底层是HashMap维护了一个哈希表，数组加链表加红黑树
- 有序：TreeSet 
- 插入与取出的顺序一致：LinkedHashSet 维护数组+双向链表
3. 一组键值对：Map
- 键无序：HashMap 底层是Hash表
- 键排序：TreeMap
- 键插入与取出的顺序一致：LinkedHashMap
- 读取文件：Properties

## Collection工具类
Collection是一个操作Set,List,Map的集合的工具类
Collection中提供了一一系列静态方法对集合中的元素进行排序，查询和修改等操作
1. 排序操作(均为static方法)
   - reverse(List) 翻转List中的元素的顺序
   - shuffle(List) 对Lis元素中的集合元素进行**随机排序**
   - sort(List , Comparator): 根据指定的Compare方法产生的顺序对List集合元素进行排序，自然排序就是根据字符串长度进行排序
   - swap(List , int , int): 将指定的List集合中的i处元素和j处元素进行交换
2. 查找、替换操作
   - Object max(Collection)根据元素的自然顺序，返回给定集合中的最大元素
   - Object max(Collection)根据Comparator指定的顺序，返回给定集合中的最大元素
   - Object min(Collection)
   - Object min(Collection,Comparator)
   - int frequency(Collection, Object) 返回指定集合中指定元素的出现次数
   - void copy(List desk, List src) 将src中的内容复制到desk中
   - boolean replaceAll(List list, Object oldVal, Object NewVal): 使用新的值替换List对象中的所有旧值
   