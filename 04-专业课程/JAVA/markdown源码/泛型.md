[[Java语言基础]]
使用传统的方法存储的是Object类不能对集合存储的数据类型进行约束，并且使用的时候需要使用向下转型，降低效率

泛型可以指定集合中存储指定对象的类型，编译器会进行检测，添加的类型不满足要求就会报错，并且遍历的时候直接取出对应的对象

泛型的定义使用
```java
List<String> stringList=new ArrayList<>();//后面可以省略
List<String> stringList=new ArrayList<String>();
```
不写类型默认为Object类型

**泛型又称参数化类型，相当于类的参数**，在类声明或者实例化的时候只要指定好需要的具体类型即可，泛型可以跳过强转过程从而不会出现类转化错误
泛型的作用就是可以在类声明的时候通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型

```java
public class exercise{
public static void main(String[] args){
Person<String> stringPerson=new Person<String>("jack");
}
}

class Person<E>{
E name;
public E f(){
return name;
}
}
```

## 注意事项
- 泛型只能传入引用类型
- 泛型指定类型后可以传入对应类型或者它的子类

## 自定义泛型
基本语法
```java
class/interface 名称<T,R>{
成员
}
```
注意细节：
- 普通成员可以使用泛型
- **使用泛型的数组不能初始化**
- 静态方法中不能使用类的泛型
- 泛型类的类型是在创建对象的时候确定的（创建对象的时候需要确定类型）
- 创建对象的时候如果没有指定泛型默认为Object
- 泛型的接口类型是在继承接口和实现接口的时候确定的
- 泛型方法可以定义在普通类中，也可以定义在泛型类中，在调用方法时候传入参数会自动确定对应类型
- 使用泛型的方法是在参数列表中使用泛型
## 泛型的通配符
泛型不具备继承性
`<?>支持任意泛型类型`
`<? extends A> 支持A类以及A类的子类，规定了泛型的上限`
`<? super A> 支持A类以及A类的父类，规定了泛型的下限`

## Junit
使用@Test注释方法可以直接运行该方法